<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RebasedPixels - Singleplayer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            padding: 20px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .settings {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tools {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .color-picker {
            margin-bottom: 15px;
        }
        
        #canvas-container {
            border: 1px solid #ccc;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        #pixel-canvas {
            cursor: crosshair;
        }
        
        button {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .tool-button {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tool-button.active {
            background-color: #2196F3;
        }
    </style>
</head>
<body>
    <h1>RebasedPixels - Singleplayer</h1>
    
    <div class="container">
        <div class="settings">
            <h3>Canvas-Einstellungen</h3>
            <div>
                <label for="canvas-width">Breite (Pixel): </label>
                <input type="number" id="canvas-width" value="16" min="4" max="64">
            </div>
            <div>
                <label for="canvas-height">H√∂he (Pixel): </label>
                <input type="number" id="canvas-height" value="16" min="4" max="64">
            </div>
            <div>
                <label for="pixel-size">Pixel-Gr√∂√üe: </label>
                <input type="number" id="pixel-size" value="20" min="10" max="40">
            </div>
            <br>
            <button id="create-canvas">Canvas erstellen</button>
            <br><br>
            <button id="clear-canvas">Canvas l√∂schen</button>
            <br><br>
            <button id="save-image">Als Bild speichern</button>
        </div>
        
        <div id="canvas-container">
            <canvas id="pixel-canvas"></canvas>
        </div>
        
        <div class="tools">
            <h3>Werkzeuge</h3>
            
            <div class="color-picker">
                <label for="color-select">Farbe: </label>
                <input type="color" id="color-select" value="#000000">
            </div>
            
            <button class="tool-button active" id="pencil-tool">
                <span>‚úèÔ∏è</span> Stift
            </button>
            
            <button class="tool-button" id="fill-tool">
                <span>ü™£</span> F√ºllen
            </button>
            
            <button class="tool-button" id="line-tool">
                <span>üìè</span> Linie
            </button>
            
            <button class="tool-button" id="rect-tool">
                <span>‚¨ú</span> Rechteck
            </button>
            
            <button class="tool-button" id="eraser-tool">
                <span>üßΩ</span> Radierer
            </button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM-Elemente
            const canvasWidthInput = document.getElementById('canvas-width');
            const canvasHeightInput = document.getElementById('canvas-height');
            const pixelSizeInput = document.getElementById('pixel-size');
            const createCanvasButton = document.getElementById('create-canvas');
            const clearCanvasButton = document.getElementById('clear-canvas');
            const saveImageButton = document.getElementById('save-image');
            const colorSelect = document.getElementById('color-select');
            const pixelCanvas = document.getElementById('pixel-canvas');
            const canvasContainer = document.getElementById('canvas-container');
            
            // Werkzeuge
            const tools = {
                pencil: document.getElementById('pencil-tool'),
                fill: document.getElementById('fill-tool'),
                line: document.getElementById('line-tool'),
                rect: document.getElementById('rect-tool'),
                eraser: document.getElementById('eraser-tool')
            };
            
            // Canvas-Variablen
            let ctx = pixelCanvas.getContext('2d');
            let pixelData = [];
            let canvasWidth = 16;
            let canvasHeight = 16;
            let pixelSize = 20;
            let currentColor = '#000000';
            let currentTool = 'pencil';
            let isDrawing = false;
            let startX, startY;
            
            // Event-Listener f√ºr Werkzeuge
            Object.keys(tools).forEach(tool => {
                tools[tool].addEventListener('click', function() {
                    // Aktiven Zustand entfernen
                    Object.values(tools).forEach(t => t.classList.remove('active'));
                    // Neues Werkzeug aktivieren
                    this.classList.add('active');
                    currentTool = tool;
                });
            });
            
            // Farbe √§ndern
            colorSelect.addEventListener('change', function() {
                currentColor = this.value;
            });
            
            // Canvas erstellen
            createCanvasButton.addEventListener('click', createCanvas);
            
            // Canvas l√∂schen
            clearCanvasButton.addEventListener('click', function() {
                clearCanvas();
                drawGrid();
            });
            
            // Als Bild speichern
            saveImageButton.addEventListener('click', function() {
                // Tempor√§res Canvas ohne Gitter erstellen
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvasWidth * pixelSize;
                tempCanvas.height = canvasHeight * pixelSize;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Pixel zeichnen
                for (let y = 0; y < canvasHeight; y++) {
                    for (let x = 0; x < canvasWidth; x++) {
                        tempCtx.fillStyle = pixelData[y][x];
                        tempCtx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
                
                // Link erstellen und klicken zum Herunterladen
                const link = document.createElement('a');
                link.download = 'rebased-pixels.png';
                link.href = tempCanvas.toDataURL();
                link.click();
            });
            
            // Mausevents f√ºr Canvas
            pixelCanvas.addEventListener('mousedown', handleMouseDown);
            pixelCanvas.addEventListener('mousemove', handleMouseMove);
            pixelCanvas.addEventListener('mouseup', handleMouseUp);
            pixelCanvas.addEventListener('mouseleave', handleMouseUp);
            
            // Canvas-Erstellung
            function createCanvas() {
                canvasWidth = parseInt(canvasWidthInput.value);
                canvasHeight = parseInt(canvasHeightInput.value);
                pixelSize = parseInt(pixelSizeInput.value);
                
                // Canvas-Gr√∂√üe festlegen
                pixelCanvas.width = canvasWidth * pixelSize;
                pixelCanvas.height = canvasHeight * pixelSize;
                
                // Pixel-Daten initialisieren
                pixelData = Array(canvasHeight).fill().map(() => 
                    Array(canvasWidth).fill('#FFFFFF')
                );
                
                // Canvas leeren und Gitter zeichnen
                clearCanvas();
                drawGrid();
            }
            
            // Canvas l√∂schen
            function clearCanvas() {
                pixelData = Array(canvasHeight).fill().map(() => 
                    Array(canvasWidth).fill('#FFFFFF')
                );
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, pixelCanvas.width, pixelCanvas.height);
                redrawCanvas();
            }
            
            // Gitter zeichnen
            function drawGrid() {
                ctx.strokeStyle = '#CCCCCC';
                ctx.lineWidth = 1;
                
                // Vertikale Linien
                for (let x = 0; x <= canvasWidth; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * pixelSize, 0);
                    ctx.lineTo(x * pixelSize, canvasHeight * pixelSize);
                    ctx.stroke();
                }
                
                // Horizontale Linien
                for (let y = 0; y <= canvasHeight; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * pixelSize);
                    ctx.lineTo(canvasWidth * pixelSize, y * pixelSize);
                    ctx.stroke();
                }
            }
            
            // Canvas neu zeichnen
            function redrawCanvas() {
                ctx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
                
                // Pixel zeichnen
                for (let y = 0; y < canvasHeight; y++) {
                    for (let x = 0; x < canvasWidth; x++) {
                        ctx.fillStyle = pixelData[y][x];
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
                
                drawGrid();
            }
            
            // Maus-Handler
            function handleMouseDown(e) {
                isDrawing = true;
                const { x, y } = getPixelCoordinates(e);
                
                startX = x;
                startY = y;
                
                if (currentTool === 'pencil') {
                    drawPixel(x, y);
                } else if (currentTool === 'fill') {
                    fillArea(x, y);
                } else if (currentTool === 'eraser') {
                    erasePixel(x, y);
                }
            }
            
            function handleMouseMove(e) {
                if (!isDrawing) return;
                
                const { x, y } = getPixelCoordinates(e);
                
                if (currentTool === 'pencil') {
                    drawPixel(x, y);
                } else if (currentTool === 'eraser') {
                    erasePixel(x, y);
                } else if (currentTool === 'line' || currentTool === 'rect') {
                    // Vorschau zeichnen
                    redrawCanvas();
                    previewShape(startX, startY, x, y);
                }
            }
            
            function handleMouseUp(e) {
                if (!isDrawing) return;
                
                const { x, y } = getPixelCoordinates(e);
                
                if (currentTool === 'line') {
                    drawLine(startX, startY, x, y);
                } else if (currentTool === 'rect') {
                    drawRectangle(startX, startY, x, y);
                }
                
                isDrawing = false;
            }
            
            // Werkzeug-Funktionen
            function drawPixel(x, y) {
                if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight) {
                    pixelData[y][x] = currentColor;
                    
                    ctx.fillStyle = currentColor;
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    
                    // Nur betroffene Linien neu zeichnen
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.beginPath();
                    ctx.moveTo(x * pixelSize, 0);
                    ctx.lineTo(x * pixelSize, canvasHeight * pixelSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo((x + 1) * pixelSize, 0);
                    ctx.lineTo((x + 1) * pixelSize, canvasHeight * pixelSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, y * pixelSize);
                    ctx.lineTo(canvasWidth * pixelSize, y * pixelSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, (y + 1) * pixelSize);
                    ctx.lineTo(canvasWidth * pixelSize, (y + 1) * pixelSize);
                    ctx.stroke();
                }
            }
            
            function erasePixel(x, y) {
                if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight) {
                    pixelData[y][x] = '#FFFFFF';
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    
                    // Nur betroffene Linien neu zeichnen
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.beginPath();
                    ctx.moveTo(x * pixelSize, 0);
                    ctx.lineTo(x * pixelSize, canvasHeight * pixelSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo((x + 1) * pixelSize, 0);
                    ctx.lineTo((x + 1) * pixelSize, canvasHeight * pixelSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, y * pixelSize);
                    ctx.lineTo(canvasWidth * pixelSize, y * pixelSize);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, (y + 1) * pixelSize);
                    ctx.lineTo(canvasWidth * pixelSize, (y + 1) * pixelSize);
                    ctx.stroke();
                }
            }
            
            function fillArea(x, y) {
                if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) return;
                
                const targetColor = pixelData[y][x];
                if (targetColor === currentColor) return;
                
                // Floodfill-Algorithmus
                const queue = [{x, y}];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    const key = `${current.x},${current.y}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    if (
                        current.x < 0 || current.x >= canvasWidth || 
                        current.y < 0 || current.y >= canvasHeight ||
                        pixelData[current.y][current.x] !== targetColor
                    ) {
                        continue;
                    }
                    
                    pixelData[current.y][current.x] = currentColor;
                    
                    // Nachbarn hinzuf√ºgen
                    queue.push({x: current.x + 1, y: current.y});
                    queue.push({x: current.x - 1, y: current.y});
                    queue.push({x: current.x, y: current.y + 1});
                    queue.push({x: current.x, y: current.y - 1});
                }
                
                redrawCanvas();
            }
            
            function drawLine(x0, y0, x1, y1) {
                // Bresenham-Algorithmus f√ºr Linien
                const dx = Math.abs(x1 - x0);
                const dy = -Math.abs(y1 - y0);
                const sx = x0 < x1 ? 1 : -1;
                const sy = y0 < y1 ? 1 : -1;
                let err = dx + dy;
                
                while (true) {
                    drawPixel(x0, y0);
                    
                    if (x0 === x1 && y0 === y1) break;
                    
                    const e2 = 2 * err;
                    if (e2 >= dy) {
                        if (x0 === x1) break;
                        err += dy;
                        x0 += sx;
                    }
                    if (e2 <= dx) {
                        if (y0 === y1) break;
                        err += dx;
                        y0 += sy;
                    }
                }
                
                redrawCanvas();
            }
            
            function drawRectangle(x0, y0, x1, y1) {
                // Eckpunkte normalisieren
                const startX = Math.min(x0, x1);
                const startY = Math.min(y0, y1);
                const endX = Math.max(x0, x1);
                const endY = Math.max(y0, y1);
                
                // Rechteck zeichnen
                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        pixelData[y][x] = currentColor;
                    }
                }
                
                redrawCanvas();
            }
            
            function previewShape(x0, y0, x1, y1) {
                if (currentTool === 'line') {
                    // Tempor√§re Linie zeichnen
                    const dx = Math.abs(x1 - x0);
                    const dy = -Math.abs(y1 - y0);
                    const sx = x0 < x1 ? 1 : -1;
                    const sy = y0 < y1 ? 1 : -1;
                    let err = dx + dy;
                    let x = x0, y = y0;
                    
                    while (true) {
                        ctx.fillStyle = currentColor;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        
                        if (x === x1 && y === y1) break;
                        
                        const e2 = 2 * err;
                        if (e2 >= dy) {
                            if (x === x1) break;
                            err += dy;
                            x += sx;
                        }
                        if (e2 <= dx) {
                            if (y === y1) break;
                            err += dx;
                            y += sy;
                        }
                    }
                    
                    drawGrid();
                } else if (currentTool === 'rect') {
                    // Tempor√§res Rechteck zeichnen
                    const startX = Math.min(x0, x1);
                    const startY = Math.min(y0, y1);
                    const endX = Math.max(x0, x1);
                    const endY = Math.max(y0, y1);
                    
                    ctx.fillStyle = currentColor;
                    for (let y = startY; y <= endY; y++) {
                        for (let x = startX; x <= endX; x++) {
                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        }
                    }
                    
                    drawGrid();
                }
            }
            
            // Hilfsfunktionen
            function getPixelCoordinates(event) {
                const rect = pixelCanvas.getBoundingClientRect();
                const scaleX = pixelCanvas.width / rect.width;
                const scaleY = pixelCanvas.height / rect.height;
                
                const x = Math.floor((event.clientX - rect.left) * scaleX / pixelSize);
                const y = Math.floor((event.clientY - rect.top) * scaleY / pixelSize);
                
                return { x, y };
            }
            
            // Initialisierung
            createCanvas();
        });
    </script>
</body>
</html> 